{{#
  Macro which generates a warning indicating how to make use of a
  Kubernetes/OpenShift-related rule. This is used by the Compliance
  Operator to automatically figure out what resources to fetch.

:param endpoint: The Kubernetes object path(s) to fetch
:type endpoint: str/list

#}}
{{% macro openshift_cluster_setting(endpoint) -%}}
This rule's check operates on the cluster configuration dump.
Therefore, you need to use a tool that can query the OCP API, retrieve the {{% if endpoint is string %}}<code class="ocp-api-endpoint">{{{ endpoint }}}</code> API endpoint to the local <code class="ocp-dump-location">{{{ xccdf_value("ocp_data_root") }}}/{{{ endpoint.lstrip("/") }}}</code> file.{{% else %}}{{% for item in endpoint %}}<code class="ocp-api-endpoint">{{{ item }}}</code> API endpoint to the local <code class="ocp-dump-location">{{{ xccdf_value("ocp_data_root") }}}/{{{ item.lstrip("/") }}}</code> file{{% endfor %}}.{{% endif %}}
{{%- endmacro %}}


{{#
  Macro which generates a warning indicating how to make use of a
  Kubernetes/OpenShift-related rule as well as how to filter it. This
  is used by the Compliance Operator to automatically figure
  out what resources to fetch. The filtering directive can be used
  by the jq command ( https://stedolan.github.io/jq/manual/ ).

:param path_filter_pairs: Kubernetes object path/filter directive pairs
:type path_filter_pairs: dict
:param varargs: A list of path_filter_pairs (in case repeated paths need to be used)
:type path_filter_pairs: list

#}}
{{% macro openshift_filtered_cluster_setting(path_filter_pairs) -%}}
This rule's check operates on the cluster configuration dump.
Therefore, you need to use a tool that can query the OCP API, retrieve the following:
<ul>
{{% for obj_path, v in path_filter_pairs.items() %}}
  {{% set vars = v.split(',') %}}
  {{% if vars|length == 2 %}}
    {{% set dump_path = vars[0] %}}
    {{% set default_filter = vars[1] %}}
    {{% set custom_filter = vars[1] %}}
  {{% elif vars|length == 3 %}}
    {{% set dump_path = vars[0] %}}
    {{% set default_filter = vars[1] %}}
    {{% set custom_filter = vars[2] %}}
  {{% else %}}
    {{% set dump_path = obj_path %}}
    {{% set default_filter = v %}}
    {{% set custom_filter = v %}}
  {{% endif %}}
  <li>
    <code class="ocp-api-endpoint" id="{{{ (dump_path+default_filter)|sha256 }}}">{{{ obj_path }}}</code>
    API endpoint, filter with with the <code>jq</code> utility using the following filter
    <code class="ocp-api-filter" id="filter-{{{ (dump_path+default_filter)|sha256 }}}">{{{ custom_filter }}}</code>
    and persist it to the local
    <code class="ocp-dump-location" id="dump-{{{ (dump_path+default_filter)|sha256 }}}">{{{ xccdf_value("ocp_data_root") }}}/{{{ dump_path.lstrip("/") }}}#{{{ (dump_path+default_filter)|sha256 }}}</code>
    file.
  </li>
{{% endfor %}}

{{% for arg in varargs %}}
    {{% for obj_path, v in arg.items() %}}
  {{% set vars = v.split(',') %}}
  {{% if vars|length == 2 %}}
    {{% set dump_path = vars[0] %}}
    {{% set default_filter = vars[1] %}}
    {{% set custom_filter = vars[1] %}}
  {{% elif vars|length == 3 %}}
    {{% set dump_path = vars[0] %}}
    {{% set default_filter = vars[1] %}}
    {{% set custom_filter = vars[2] %}}
  {{% else %}}
    {{% set dump_path = obj_path %}}
    {{% set default_filter = v %}}
    {{% set custom_filter = v %}}
  {{% endif %}}
    <li>
        <code class="ocp-api-endpoint" id="{{{ (dump_path+default_filter)|sha256 }}}">{{{ obj_path }}}</code>
        API endpoint, filter with with the <code>jq</code> utility using the following filter
        <code class="ocp-api-filter" id="filter-{{{ (dump_path+default_filter)|sha256 }}}">{{{ custom_filter }}}</code>
        and persist it to the local
        <code class="ocp-dump-location" id="dump-{{{ (dump_path+default_filter)|sha256 }}}">{{{ xccdf_value("ocp_data_root") }}}/{{{ dump_path.lstrip("/") }}}#{{{ (dump_path+default_filter)|sha256 }}}</code>
        file.
    </li>
    {{% endfor %}}
{{% endfor %}}
</ul>
{{%- endmacro %}}


{{#
  Macro which generates a unique path for a filtered Kubernetes
  resource. The path and the filter are used to generate a unique
  identifier in such a way that it won't conflict with unfiltered
  resources

:param path: The Kubernetes object path to fetch
:type path: str
:param filter: A filtering directive
:type filter: str

#}}
{{% macro openshift_filtered_path(path, filter) -%}}
{{{ path }}}#{{{ (path+filter)|sha256 }}}
{{%- endmacro %}}


{{#
  Macro that creates a check from :code:`oc` output
#}}
{{% macro ocil_oc_pipe_jq_filter(object, jqfilter, namespace=none, all_namespaces=false) -%}}
oc get {{% if all_namespaces %}}--all-namespaces{{% elif namespace %}}-n {{{ namespace }}}{{% endif %}} {{{ object }}} -o json | jq '{{{ jqfilter }}}'
{{%- endmacro %}}


{{% macro sshd_config_file() %}}
    {{% if sshd_distributed_config == "true" %}}
    <tt>/etc/ssh/sshd_config.d/00-complianceascode-hardening.conf</tt>:
    {{% else %}}
    <tt>/etc/ssh/sshd_config</tt>:
    {{% endif %}}
{{%- endmacro %}}


{{#
    Calls :code:`xccdf_value` macro under the hood

:param varname: The name of the variable to reference
:type varname: str

#}}
{{% macro sub_var_value(varname) -%}}
{{{ xccdf_value(varname) }}}
{{%- endmacro %}}


{{#
    Create an XCCDF :code:`<sub>` element

:param varname: The name of the variable to reference
:type varname: str

#}}
{{% macro xccdf_value(varname) -%}}
<sub idref="{{{ varname }}}" />
{{%- endmacro %}}


{{% macro _iptables_desc(traffic_action, how_to_do, proto, port) -%}}
    To configure <tt>iptables</tt> {{{ traffic_action }}} port {{{ port }}} traffic, one must edit
    <tt>/etc/sysconfig/iptables</tt> and
    <tt>/etc/sysconfig/ip6tables</tt> (if IPv6 is in use).
    {{{ how_to_do }}}
    <pre>-A INPUT -m state --state NEW -p {{{ proto }}} --dport {{{ port }}} -j ACCEPT</pre>
{{%- endmacro %}}


{{#
    Describe an iptables block

:param proto: protocol to block
:type proto: str
:param port: port to block
:type port: int

#}}
{{% macro describe_iptables_block(proto, port) -%}}
{{{ _iptables_desc(
	traffic_action="to block",
	how_to_do="Remove the following line, ensuring that it does not appear the INPUT chain:",
	proto=proto,
	port=port
) }}}
{{%- endmacro %}}


{{#
    Describe an iptables allow

:param proto: protocol to allow
:type proto: str
:param port: port to allow
:type port: int

#}}
{{% macro describe_iptables_allow(proto, port) -%}}
{{{ _iptables_desc(
	traffic_action="to allow",
	how_to_do="Add the following line, ensuring that it appears before the final LOG and DROP lines for the INPUT chain:",
	proto=proto,
	port=port
) }}}
{{%- endmacro %}}


{{#
    Describe how to check if given path is on its own partition or logical volume.

:param part: Path to check
:type part: str

#}}
{{% macro partition_check(part) -%}}
    {{% if product == "rhcos4" -%}}
    You'll need to log into a node in the cluster.
    {{{ rhcos_node_login_instructions() }}}
    Subsequently,
    {{%- endif -%}}
    Run the following command to determine if <code>{{{ part }}}</code>
    is on its own partition or logical volume:
    <pre>$ mount | grep "on {{{ part }}}"</pre>
    If <code>{{{ part }}}</code> has its own partition or volume group, a line will be returned.
{{%- endmacro %}}


{{#
    OCIL for how to check if given path is on its own partition or logical volume and the
    correct OCIL clause.

:param part: Path to check
:type part: str

#}}
{{% macro complete_ocil_entry_separate_partition(part) -%}}
ocil: |
    {{{ partition_check(part) }}}

ocil_clause: "no line is returned"
{{%- endmacro %}}




{{#
    Describe preventing access a port or service in firewalld. If the :code:`service` parameter is defined
    it is assumed to be a service and the :code:`port` and :code:`proto` parameters will have no effect.

:param port: The port to allow
:type port: int
:param proto: The protocol to allow
:type proto: str
:param service: The service to allow
:type service: str

#}}
{{%- macro describe_firewalld_prevent(port, proto, service) %}}
    To configure <code>firewalld</code> to prevent access, run the following command(s):
    {{% if port %}}
    <code>firewall-cmd --permanent --remove-port={{{ port }}}/{{{ proto }}}</code>
    {{% endif %}}
    {{% if service %}}
    <code>firewall-cmd --permanent --remove-service={{{ service }}}</code>
    {{% endif %}}
{{%- endmacro %}}


{{#
    Describe allowing access a port or service in firewalld. If the :code:`service` parameter is defined
    it is assumed to be a service and the :code:`port` and :code:`proto` parameters will have no effect.

:param port: The port to allow
:type port: int
:param proto: The protocol to allow
:type proto: str
:param service: The service to allow
:type service: str

#}}
{{%- macro describe_firewalld_allow(port, proto, service) %}}
    To configure <code>firewalld</code> to allow access, run the following command(s):
    {{% if port %}}
    <code>firewall-cmd --permanent --add-port={{{ port }}}/{{{ proto }}}</code>
    {{% endif %}}
    {{% if service %}}
    <code>firewall-cmd --permanent --add-service={{{ service }}}</code>
    {{% endif %}}
{{%- endmacro %}}




{{#
    OCIL for disabling a kernel module.

:param module: The module to disable.
:type module: str

#}}
{{%- macro ocil_module_disable(module) %}}
    If the system is configured to prevent the loading of the <code>{{{ module }}}</code> kernel module,
    it will contain lines inside any file in <code>/etc/modprobe.d</code> or the deprecated<code>/etc/modprobe.conf</code>.
    These lines instruct the module loading system to run another program (such as <code>/bin/true</code>) upon a module <code>install</code> event.
    Run the following command to search for such lines in all files in <code>/etc/modprobe.d</code> and the deprecated <code>/etc/modprobe.conf</code>:
    <pre>$ grep -r {{{ module }}} /etc/modprobe.conf /etc/modprobe.d</pre>
{{%- endmacro %}}


{{#
    OCIL and OCIL clause for disabling a kernel module.

:param module: The module to disable.
:type module: str

#}}
{{%- macro complete_ocil_entry_module_disable(module) %}}
ocil: |-
    {{{ ocil_module_disable(module) }}}

ocil_clause: "no line is returned"
{{%- endmacro %}}


{{#
    Description for how to check for a disabled kernel module.

:param module: The module to disable.
:type module: str

#}}
{{%- macro describe_module_disable(module) %}}
    To configure the system to prevent the <code>{{{ module }}}</code>
    kernel module from being loaded, add the following line to a file in the directory <code>/etc/modprobe.d</code>:
    <pre>install {{{ module }}} /bin/true</pre>
{{%- endmacro %}}


{{#
    Describe how to check if a service is disabled via chkconfig.

:param service: The service to check
:type service: str

#}}
{{%- macro ocil_xinetd_service_disabled(service) %}}
    To check that the <code>{{{ service }}}</code> service is disabled in system boot configuration, run the following command:
    <pre>$ sudo chkconfig <code>{{{ service }}}</code> --list</pre>
    Output should indicate the <code>{{{ service }}}</code> service has either not been installed, or has been disabled, as shown in the example below:
    <pre>$ sudo chkconfig <code>{{{ service }}}</code> --list
    <code>{{{ service }}}</code>       off</pre>
{{%- endmacro %}}


{{#
    Describe how to disable socket in systemd.

:param socket: The socket to check
:type socket: str

#}}
{{%- macro systemd_describe_socket_disable(socket) %}}
    The <code>{{{ socket }}}</code> socket can be disabled with the following command:
    <pre>$ sudo systemctl mask --now {{{ socket }}}.socket</pre>
{{%- endmacro %}}


{{%- macro upstart_describe_socket_disable(socket) %}}
{{%- endmacro %}}


{{#
    Describe how to enable a socket in systemd.

:param socket: The socket to check
:type socket: str

#}}
{{%- macro systemd_describe_socket_enable(socket) %}}
    The <code>{{{ socket }}}</code> socket can be enabled with the following command:
    <pre>$ sudo systemctl enable {{{ socket }}}.socket</pre>
{{%- endmacro %}}


{{%- macro upstart_describe_socket_enable(socket) %}}
{{%- endmacro %}}


{{#
    Describe how to disable a service in systemd.

:param service: The service to check
:type service: str

#}}
{{%- macro systemd_describe_service_disable(service) %}}
    {{% if product != "rhcos4" -%}}
    The <code>{{{ service }}}</code> service can be disabled with the following command:
    <pre>$ sudo systemctl mask --now {{{ service }}}.service</pre>
    {{%- else -%}}
    The <code>{{{ service }}}</code> service can be disabled with the following manifest:
    <pre>
    ---
    apiVersion: machineconfiguration.openshift.io/v1
    kind: MachineConfig
    metadata:
      labels:
        machineconfiguration.openshift.io/role: master
      name: 75-master-{{{ service }}}-disable
    spec:
      config:
        ignition:
          version: 3.1.0
        systemd:
          units:
          - enabled: false
            name: {{{ service }}}.service
    </pre>
    <p>
    This will disable the <tt>{{{ service }}}</tt> service in all the
    nodes labeled with the "master" role.
    </p>
    {{{ machineconfig_description_footer() | indent(4) }}}
    {{%- endif %}}
{{%- endmacro %}}


{{#
    Describe how to enable a service in systemd.

:param service: The service to check
:type service: str

#}}
{{%- macro systemd_describe_service_enable(service) %}}
    {{% if product != "rhcos4" -%}}
    The <code>{{{ service }}}</code> service can be enabled with the following command:
    <pre>$ sudo systemctl enable {{{ service }}}.service</pre>
    {{%- else -%}}
    The <code>{{{ service }}}</code> service can be enabled with the following manifest:
    <pre>
    ---
    apiVersion: machineconfiguration.openshift.io/v1
    kind: MachineConfig
    metadata:
      labels:
        machineconfiguration.openshift.io/role: master
      name: 75-master-{{{ service }}}-enable
    spec:
      config:
        ignition:
          version: 3.1.0
        systemd:
          units:
          - name: {{{ service }}}.service
            enabled: true
    </pre>
    <p>
    This will enable the <tt>{{{ service }}}</tt> service in all the
    nodes labeled with the "master" role.
    </p>
    {{{ machineconfig_description_footer() | indent(4) }}}
    {{%- endif %}}
{{%- endmacro %}}


{{#
    Describe how to disable a service in upstart.

:param service: The service to check
:type service: str

#}}
{{%- macro upstart_describe_service_disable(service) %}}
    The <code>{{{ service }}}</code> service can be disabled with the following command:
    <pre>$ sudo chkconfig {{{ service }}} off</pre>
{{%- endmacro %}}


{{#
    Describe how to enable a service in upstart.

:param service: The service to check
:type service: str

#}}
{{%- macro upstart_describe_service_enable(service) %}}
    The <code>{{{ service }}}</code> service can be enabled with the following command:
    <pre>$ sudo chkconfig --level 2345 {{{ service }}} on</pre>
{{%- endmacro %}}

{{%- macro systemd_describe_timer_enable(timer) %}}
    The <code>{{{ timer }}}</code> timer can be enabled with the following command:
    <pre>$ sudo systemctl enable {{{ timer }}}.timer</pre>
{{%- endmacro %}}


{{#
    Describe how to check if timer is enabled in upstart.

:param service: The service to check
:type service: str

#}}
{{%- macro systemd_ocil_timer_enabled(timer) %}}
    Run the following command to determine the current status of the
    <code>{{{ timer }}}</code> timer:
    <pre>$ systemctl is-active {{{ timer }}}.timer</pre>
    If the timer is running, it should return the following: <pre>active</pre>
{{%- endmacro %}}


{{#
    Describe how to check if given SELinux boolean is disabled.

:param sebool: The SELinux boolean to check
:type sebool: str

#}}
{{%- macro describe_sebool_check_disabled(sebool) %}}
    Run the following command to determine if the <code>{{{ sebool }}}</code> SELinux boolean is disabled:
    <pre>$ getsebool {{{ sebool }}}</pre>
    If properly configured, the output should show the following:
    <code>{{{ sebool }}} --> off</code>
{{%- endmacro %}}


{{#
    OCIL and OCIL clause for how to check if given SELinux boolean is disabled.

:param sebool: The SELinux boolean to check
:type sebool: str

#}}
{{%- macro complete_ocil_entry_sebool_disabled(sebool) %}}
ocil: |-
    {{{ describe_sebool_check_disabled(sebool) }}}

ocil_clause: "{{{ sebool }}} is not disabled"
{{%- endmacro %}}


{{#
    Describe how to check if given SELinux boolean is enabled.

:param sebool: The SELinux boolean to check
:type sebool: str

#}}
{{%- macro describe_sebool_check_enabled(sebool) %}}
    Run the following command to determine if the <code>{{{ sebool }}}</code> SELinux boolean is enabled:
    <pre>$ getsebool {{{ sebool }}}</pre>
    If properly configured, the output should show the following:
    <code>{{{ sebool }}} --> on</code>
{{%- endmacro %}}


{{#
    OCIL and OCIL clause for how to check if given SELinux boolean is enabled.

:param sebool: The SELinux boolean to check
:type sebool: str

#}}
{{%- macro complete_ocil_entry_sebool_enabled(sebool) %}}
ocil: |-
    {{{ describe_sebool_check_enabled(sebool) }}}

ocil_clause: "{{{ sebool }}} is not enabled"
{{%- endmacro %}}


{{#
    Describe how to disable an SELinux boolean.

:param sebool: The SELinux boolean to disable
:type sebool: str

#}}
{{%- macro describe_sebool_disable(sebool) %}}
    To disable the <code>{{{ sebool }}}</code> SELinux boolean, run the following command:
    <pre>$ sudo setsebool -P {{{ sebool }}} off</pre>
{{%- endmacro %}}


{{#
    Describe how to enable an SELinux boolean.

:param sebool: The SELinux boolean to disable
:type sebool: str

#}}
{{%- macro describe_sebool_enable(sebool) %}}
    To enable the <code>{{{ sebool }}}</code> SELinux boolean, run the following command:
    <pre>$ sudo setsebool -P {{{ sebool }}} on</pre>
{{%- endmacro %}}


{{#
    Show how to install a package with apt-get.

    Example output::

        apt-get install package

:param package: Package to install
:type package: str

#}}
{{%- macro apt_get_package_install(package) %}}
    $ apt-get install {{{ package }}}
{{%- endmacro %}}


{{#
    Show how to remove a package with apt-get.

    Example output::

        $ apt-get remove package

:param package: Package to remove
:type package: str

#}}
{{%- macro apt_get_package_remove(package) %}}
    $ apt-get remove {{{ package }}}
{{%- endmacro %}}


{{#
    Show how to install a package with dnf.

    Example output::

        $ sudo dnf install package

:param package: Package to install
:type package: str

#}}
{{%- macro dnf_package_install(package) %}}
    $ sudo dnf install {{{ package }}}
{{%- endmacro %}}


{{#
    Show how to remove a package with dnf.

    Example output::

        $ sudo dnf erase remove package

:param package: Package to remove
:type package: str

#}}
{{%- macro dnf_package_remove(package) %}}
    $ sudo dnf erase {{{ package }}}
{{%- endmacro %}}


{{#
    Show how to install a package with yum.

    Example output::

        $ sudo yum install package

:param package: Package to install
:type package: str

#}}
{{%- macro yum_package_install(package) %}}
    $ sudo yum install {{{ package }}}
{{%- endmacro %}}


{{#
    Show how to remove a package with yum.

    Example output::

        $ sudo yum erase package

:param package: Package to remove
:type package: str

#}}
{{%- macro yum_package_remove(package) %}}
    $ sudo yum erase {{{ package }}}
{{%- endmacro %}}


{{#
    Show how to install a package with zypper.

    Example output::

        $ sudo zypper install package

:param package: Package to install
:type package: str

#}}
{{%- macro zypper_package_install(package) %}}
    $ sudo zypper install {{{ package }}}
{{%- endmacro %}}


{{#
    Show how to remove a package with zypper.

    Example output::

        $ sudo zypper remove package

:param package: Package to remove
:type package: str

#}}
{{%- macro zypper_package_remove(package) %}}
    $ sudo zypper remove {{{ package }}}
{{%- endmacro %}}


{{#
    Describe how to set the permissions on a file.

:param file: File to change
:type file: str
:param perms: The permissions for the file
:type perms: str

#}}
{{%- macro describe_file_permissions(file, perms) %}}
    To properly set the permissions of <code>{{{ file }}}</code>, run the command:
    <pre>$ sudo chmod {{{ perms }}} {{{ file }}}</pre>
{{%- endmacro %}}


{{#
    Describe how to set the file owner of a file.

:param file: File to change
:type file: str
:param owner: the owner for the file
:type owner: str

#}}
{{%- macro describe_file_owner(file, owner) %}}
    To properly set the owner of <code>{{{ file }}}</code>, run the command:
    <pre>$ sudo chown {{{ owner }}} {{{ file }}} </pre>
{{%- endmacro %}}


{{#
    Describe how to set the file group owner of a file.

:param file: File to change
:type file: str
:param group: The group owner for the file
:type group: str
#}}
{{%- macro describe_file_group_owner(file, group) %}}
    To properly set the group owner of <code>{{{ file }}}</code>, run the command:
    <pre>$ sudo chgrp {{{ group }}} {{{ file }}}</pre>
{{%- endmacro %}}


{{#
    OCIL for how to check the permissions on a file.

:param file: File to change
:type file: str
:param perms: The permissions for the file
:type perms: str

#}}
{{%- macro ocil_file_permissions(file, perms) -%}}
    To check the permissions of <code>{{{ file }}}</code>,
    {{% if product == "rhcos4" or product == "ocp4" -%}}
    you'll need to log into a node in the cluster.
    {{{ rhcos_node_login_instructions() }}}
    Then,
    {{%- endif -%}}
    run the command:
    <pre>$ ls -l {{{ file }}}</pre>
    If properly configured, the output should indicate the following permissions:
    <code>{{{ perms }}}</code>
{{%- endmacro %}}


{{#
    OCIL how to check the file owner of a file.

:param file: File to change
:type file: str
:param owner: The owner for the file
:type owner: str

#}}
{{%- macro ocil_file_owner(file, owner) -%}}
    To check the ownership of <code>{{{ file }}}</code>,
    {{% if product == "rhcos4" or product == "ocp4" -%}}
    you'll need to log into a node in the cluster.
    {{{ rhcos_node_login_instructions() }}}
    Then,
    {{%- endif -%}}
    run the command:
    <pre>$ ls -lL {{{ file }}}</pre>
    If properly configured, the output should indicate the following owner:
    <code>{{{ owner }}}</code>
{{%- endmacro %}}


{{#
    OCIL how to check the file group owner of a file.

:param file: File to change
:type file: str
:param group: the group owner for the file
:type group: str

#}}
{{%- macro ocil_file_group_owner(file, group) -%}}
    To check the group ownership of <code>{{{ file }}}</code>,
    {{% if product == "rhcos4" or product == "ocp4" -%}}
    you'll need to log into a node in the cluster.
    {{{ rhcos_node_login_instructions() }}}
    Then,
    {{%- endif -%}}
    run the command:
    <pre>$ ls -lL {{{ file }}}</pre>
    If properly configured, the output should indicate the following group-owner:
    <code>{{{ group }}}</code>
{{%- endmacro %}}


{{#
    OCIL clause for file permissions

:param file: File to change
:type file: str
:param perms: the permissions for the file
:type perms: str

#}}
{{%- macro ocil_clause_file_permissions(file, perms) -%}}
    {{{ file }}} has unix mode {{{ perms }}}
{{%- endmacro %}}


{{#
    OCIL clause for file owner

:param file: File to change
:type file: str
:param owner: the owner for the file
:type owner: str

#}}
{{%- macro ocil_clause_file_owner(file, owner) -%}}
    {{{ file }}} has owner {{{ owner }}}
{{%- endmacro %}}


{{#
    OCIL clause for file group owner

:param file: File to change
:type file: str
:param owner: the group owner for the file
:type owner: str

#}}
{{%- macro ocil_clause_file_group_owner(file, group) -%}}
    {{{ file }}} has group owner {{{ group }}}
{{%- endmacro %}}


{{#
    How to check a file for the correct permissions.

:param file: File to change
:type file: str
:param perms: The permissions for the file
:type perms: str
#}}
{{%- macro check_file_permissions(file, perms) %}}
    To check the permissions of <code>{{{ file }}}</code>, run the command:
    <pre>$ ls -l {{{ file }}}</pre>
    If properly configured, the output should indicate the following permissions:
    <code>{{{ perms }}}</code>
{{%- endmacro %}}


{{#
    How add mount options to :code:`/etc/fstab`

:param option: The option to add to the partition
:type option: str
:param part: The partition
:type part: str

#}}
{{% macro describe_mount(option, part) -%}}
    {{% if product != "rhcos4" -%}}
    Add the <code>{{{ option }}}</code> option to the fourth column of
    <tt>/etc/fstab</tt> for the line which controls mounting of
    {{% if part.startswith('/') -%}}
        <code>{{{ part }}}</code>.
    {{%- else %}}
        {{{ part }}}.
    {{%- endif %}}
    {{%- else -%}}
    Add the <code>{{{ option }}}</code> option to the list of
    <code>Options</code> in the <code>systemd.mount</code> unit that
    controls mounting of
    {{% if part.startswith('/') -%}}
        <code>{{{ part }}}</code>.
    {{%- else %}}
        {{{ part }}}.
    {{%- endif %}}
    {{%- endif %}}
{{%- endmacro %}}


{{#
    Describe the separate partition is needed.

:param part: The partition
:type part: str

#}}
{{% macro partition_description(part) -%}}
    {{% if product == "rhcos4" or product == "ocp4" -%}}
    <p>
    Partitioning Red Hat CoreOS is a Day 1 operation and cannot
    be changed afterwards. For documentation on how to add a
    MachineConfig manifest that specifies a separate <code>{{{ part }}}</code>
    partition, follow:
    {{{ weblink(link="https://docs.openshift.com/container-platform/latest/installing/installing_platform_agnostic/installing-platform-agnostic.html#installation-user-infra-machines-advanced_disk_installing-platform-agnostic") }}}
    </p>
    <p>
    Note that the Red Hat OpenShift documentation often references a block
    device, such as <tt>/dev/vda</tt>. The name of the available block devices depends
    on the underlying infrastructure (bare metal vs cloud), and often the specific
    instance type. For example in AWS, some instance types have NVMe drives
    (<tt>/dev/nvme*</tt>), others use <tt>/dev/xvda*</tt>.

    You will need to look for relevant documentation for your infrastructure around this.
    In many cases, the simplest thing is to boot a single machine with an Ignition
    configuration that just gives you SSH access, and inspect the block devices via
    e.g. the <tt>lsblk</tt> command.

    For physical hardware, a good best practice is to reference devices via the
    <tt>/dev/disk/by-id/</tt> or <tt>/dev/disk/by-path</tt> links.
    </p>
    {{% else %}}
    Ensure that <code>{{{ part }}}</code> has its own partition or logical
    volume at installation time, or migrate it using LVM.
    {{%- endif %}}
{{%- endmacro %}}


{{#
    OCIL for a sysctl option

:param sysctl: The kernel parameter to change
:type sysctl: str
:param value: The value to be set
:type value: str

#}}
{{% macro ocil_sysctl_option_value(sysctl, value) -%}}
    The runtime status of the <code>{{{ sysctl }}}</code> kernel parameter can be queried
    by running the following command:
    <pre>$ sysctl {{{ sysctl }}}</pre>
    The output of the command should indicate a value of <code>{{{ value }}}</code>.
    The preferable way how to assure the runtime compliance is to have
    correct persistent configuration, and rebooting the system.

    The persistent kernel parameter configuration is performed by specifying the appropriate
    assignment in any file located in the <pre>/etc/sysctl.d</pre> directory.
    Verify that there is not any existing incorrect configuration by executing the following command:
    <pre>$ grep -r '^\s*{{{ sysctl }}}\s*=' /etc/sysctl.conf /etc/sysctl.d</pre>
    If any assignments other than
    <pre>{{{ sysctl }}} = {{{ value }}}</pre>
    are found, or the correct assignment is duplicated, remove those offending lines from respective files,
    and make sure that exactly one file in
    <code>/etc/sysctl.d</code> contains <code>{{{ sysctl }}} = {{{ value }}}</code>, and that one assignment
    is returned when
    <pre>$ grep -r {{{ sysctl }}} /etc/sysctl.conf /etc/sysctl.d</pre>
    is executed.
{{%- endmacro %}}


{{#
    OCIL and OCIL clause for a sysctl option

:param sysctl: The kernel parameter to change
:type sysctl: str
:param value: The value to be set
:type value: str

#}}
{{% macro complete_ocil_entry_sysctl_option_value(sysctl, value) -%}}
ocil: |
    {{{ ocil_sysctl_option_value(sysctl, value) }}}

ocil_clause: "the correct value is not returned"
{{%- endmacro %}}


{{#
    Describe how to set a sysctl kernel parameter.

:param sysctl: The kernel parameter to change
:type sysctl: str
:param value: The value to be set
:type value: str

#}}
{{% macro describe_sysctl_option_value(sysctl, value) -%}}
    To set the runtime status of the <code>{{{ sysctl }}}</code> kernel parameter,
    run the following command:
    <pre>$ sudo sysctl -w {{{ sysctl }}}={{{ value }}}</pre>

    To make sure that the setting is persistent,
    add the following line to a file in the directory <tt>/etc/sysctl.d</tt>:
    <pre>{{{ sysctl }}} = {{{ value }}}</pre>
{{%- endmacro %}}


{{#
    Creates an HTML :code:`<a>` element for the given link and text. If no text is given the
    link will be the text

:param link: The url the link should have
:type link: str
:param text: Optional, text for the link
:type text: str

#}}
{{% macro weblink(link, text=none) -%}}
    {{% if text is not none -%}}
        <a xmlns='http://www.w3.org/1999/xhtml' href='{{{ link }}}'>{{{ text }}}</a>
    {{%- else %}}
        <a xmlns='http://www.w3.org/1999/xhtml' href='{{{ link }}}'>{{{ link }}}</a>
    {{%- endif %}}
{{%- endmacro %}}


{{#
    A warning about rule depending on another.

:param rule_id: Rule id of the rule that must be selected.
:type rule_id: str
:param why: The reasoning for the dependency. Should fit into this part of the sentence "make sure that rule with ID is selected as well:".
:type why: str

#}}
{{% macro body_of_warning_about_dependent_rule(rule_id, why) -%}}
        When selecting this rule in a profile,
        {{%- if why %}}
            make sure that rule with ID <code>{{{ rule_id }}}</code> is selected as well: {{{ why }}}
        {{%- else %}}
            rule <code>{{{ rule_id }}}</code> has to be selected as well.
        {{%- endif %}}
{{% endmacro %}}


{{#
    An openssl config file with strong entropy.
#}}
{{% macro openssl_strong_entropy_config_file() -%}}
# provide a default -rand /dev/random option to openssl commands that
# support it

# written inefficiently for maximum shell compatibility
openssl()
(
  openssl_bin=/usr/bin/openssl

  case "$*" in
    # if user specified -rand, honor it
    *\ -rand\ *|*\ -help*) exec $openssl_bin "$@" ;;
  esac

  cmds=`$openssl_bin list -digest-commands -cipher-commands | tr '\n' ' '`
  for i in `$openssl_bin list -commands`; do
    if $openssl_bin list -options "$i" | grep -q '^rand '; then
      cmds=" $i $cmds"
    fi
  done

  case "$cmds" in
    *\ "$1"\ *)
      cmd="$1"; shift
      exec $openssl_bin "$cmd" -rand /dev/random "$@" ;;
  esac

  exec $openssl_bin "$@"
)

{{%- endmacro %}}


{{#
    A note about an item need be done for each :code:`MachineConfigPool`.
#}}
{{% macro machineconfig_description_footer() -%}}
<p>
Note that this needs to be done for each <tt>MachineConfigPool</tt>
</p>
<p>
For more information on how to configure nodes with the Machine Config
Operator see
{{{ weblink(link="https://docs.openshift.com/container-platform/4.6/post_installation_configuration/machine-configuration-tasks.html",
            text="the relevant documentation") }}}.
</p>
{{% endmacro %}}


{{#
    Adds a boiler plate warning with a justification why a rule is disabled on RHV.
    Note: This is only applied on RHEL8 content.

    :param rationale: Explanation why RHV needs the rule disabled.
#}}
{{% macro ovirt_rule_notapplicable_warning(rationale) %}}
{{%- if product == "rhel8" %}}
- general: |-
    This rule is disabled on Red Hat Virtualization Hosts and Managers, it will report not applicable.
    {{{ rationale }}}.
{{%- endif %}}
{{% endmacro %}}

{{#

    Makes a rule not applicable on systems where oVirt is installed.
    Note: This is only applied on RHEL8 content.

#}}
{{% macro rule_notapplicable_when_ovirt_installed() %}}
{{%- if product == "rhel8" %}}
- no_ovirt
{{%- endif %}}
{{% endmacro %}}

{{#
    Describe how to configure Grub2 to add an argument to the default kernel command line.
    The parameter should be in form `parameter=value`.
#}}
{{%- macro describe_grub2_argument(arg_name_value) -%}}
{{%- if product in ["rhel7", "ol7", "rhel8", "ol8", "rhel9"] or 'ubuntu' in product -%}}
To ensure that <tt>{{{ arg_name_value }}}</tt> is added as a kernel command line
argument to newly installed kernels, add <tt>{{{ arg_name_value }}}</tt> to the
default Grub2 command line for Linux operating systems.  Modify the line within
<tt>/etc/default/grub</tt> as shown below:
<pre>GRUB_CMDLINE_LINUX="... {{{ arg_name_value }}} ..."</pre>
Run the following command to update command line for already installed kernels:
{{%- if 'ubuntu' in product -%}}
<pre># update-grub</pre>
{{%- else -%}}
<pre># grubby --update-kernel=ALL --args="{{{ arg_name_value }}}"</pre>
{{%- endif -%}}
{{%- else -%}}
Configure the default Grub2 kernel command line to contain {{{ arg_name_value }}} as follows:
<pre># grub2-editenv - set "$(grub2-editenv - list | grep kernelopts) {{{ arg_name_value }}}"</pre>
{{%- endif -%}}
{{%- endmacro -%}}

{{#
    Provide OCIL for checking if an argument for kernel command line is configured with Grub2.
    The parameter should have form `parameter=value`.
#}}
{{%- macro ocil_grub2_argument(arg_name_value) -%}}
{{%- if product in ["rhel7", "ol7", "rhel8", "ol8", "rhel9"] or 'ubuntu' in product -%}}
Inspect the form of default GRUB 2 command line for the Linux operating system
in <tt>/etc/default/grub</tt>. If it includes <tt>{{{ arg_name_value }}}</tt>,
then the parameter will be configured for newly installed kernels.
First check if the GRUB recovery is enabled:
<pre>$ grep 'GRUB_DISABLE_RECOVERY' /etc/default/grub</pre>
If this option is set to true, then check that a line is output by the following command:
<pre>$ grep 'GRUB_CMDLINE_LINUX_DEFAULT.*{{{ arg_name_value }}}.*' /etc/default/grub</pre>
If the recovery is disabled, check the line with
<pre>$ grep 'GRUB_CMDLINE_LINUX.*{{{ arg_name_value }}}.*' /etc/default/grub</pre>.
{{%- if 'ubuntu' in product -%}}
Moreover, current Grub config file <tt>grub.cfg</tt> must be checked. The file can be found
either in <tt>{{{ grub2_boot_path }}}</tt> in case of legacy BIOS systems, or in <tt>{{{ grub2_uefi_boot_path }}}</tt> in case of UEFI systems.
If they include <tt>{{{ arg_name_value }}}</tt>, then the parameter
is configured at boot time.
<pre># grep vmlinuz GRUB_CFG_FILE_PATH | grep -v '{{{ arg_name_value }}}'</pre>
Fill in <tt>GRUB_CFG_FILE_PATH</tt> based on information above.
This command should not return any output.
{{%- else -%}}
Moreover, command line parameters for currently installed kernels should be checked as well.
Run the following command:
<pre># grubby --info=ALL | grep args | grep -v '{{{ arg_name_value }}}'</pre>
The command should not return any output.
{{%- endif -%}}
{{%- else -%}}
Inspect the form of default GRUB 2 command line for the Linux operating system
{{% if grub2_boot_path == grub2_uefi_boot_path or not grub2_uefi_boot_path -%}}
in <tt>{{{ grub2_boot_path }}}/grubenv</tt>.
{{%- else -%}}
in <tt>grubenv</tt> that can be found either in <tt>{{{ grub2_boot_path }}}</tt> in case of legacy BIOS systems, or in <tt>{{{ grub2_uefi_boot_path }}}</tt> in case of UEFI systems.
{{%- endif %}}
If they include <tt>{{{ arg_name_value }}}</tt>, then the parameter
is configured at boot time.
<pre># grep 'kernelopts.*{{{ arg_name_value }}}.*' GRUBENV_FILE_LOCATION</pre>
Fill in <tt>GRUBENV_FILE_LOCATION</tt> based on information above.
{{%- endif -%}}
{{%- endmacro -%}}

{{#
    Describe how to check a kernel compile parameter

:param config: The kernel config parameter
:type config: str
:param value: The value for the given config
:type value: str

#}}
{{% macro kernel_build_config_describe_config(config, value) -%}}
    The configuration that was used to build kernel is available at <tt>/boot/config-*</tt>.
    To check the configuration value for <tt>{{{ config }}}</tt>, run the following command:
    <tt>grep {{{ config }}} /boot/config-*</tt>
    {{% if value == "n" %}}
    Configs with value 'n' are not explicitly set in the file, so either commented lines or no
    lines should be returned.
    {{% else %}}
    For each kernel installed, a line with value "{{{ value }}}" should be returned.
    {{% endif %}}
{{%- endmacro %}}

{{#
    Adds a default "no easy remediation" warning for kernel_build_config warning.
#}}
{{% macro kernel_build_config_warning() %}}
- general: |-
    There is no remediation for this besides re-compiling the kernel with the appropriate value for the config.
{{% endmacro %}}

{{#
    OCIL for a kernel build config rule.

    Example usage::

        ocil_kernel_build_config(config="config_kernel_strict_rwx", value="y")

:param config: The kernel config parameter
:type config: str
:param value: The value for the given config
:type value: str

#}}
{{% macro kernel_build_config_ocil(config, value) -%}}
    To determine the config value the kernel was built with, run the following command:
    <pre>$ grep {{{ config }}} /boot/config.*</pre>
    {{% if value == "n" %}}
    Configs with value 'n' are not explicitly set in the file, so either commented lines or no
    lines should be returned.
    {{% else %}}
    For each kernel installed, a line with value "{{{ value }}}" should be returned.
    {{% endif %}}
{{%- endmacro %}}


{{#
    Macro describing fix for sysctl rules.

:param sysctl: The kernel parameter to be changed.
:type sysctl: str
:param value: The value of the kernel parameter.
:type value: str

#}}
{{% macro fix_sysctl(sysctl, value) -%}}
Add or edit the following line in a system configuration file in the "/etc/sysctl.d/" directory:

{{{ sysctl }}} = {{{ value }}}

Load settings from all system configuration files with the following command:

$ sudo sysctl --system
{{%- endmacro %}}
